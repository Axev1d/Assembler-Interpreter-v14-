<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <title>УВМ — вариант 14 (Web GUI)</title>

    <style>
        body {
            margin: 0;
            font-family: sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 8px 12px;
            background: #222;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .container {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            padding: 4px;
            box-sizing: border-box;
        }

        .panel {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .panel label {
            font-weight: bold;
            margin-bottom: 4px;
        }

        textarea, pre {
            flex: 1;
            width: 100%;
            box-sizing: border-box;
            resize: none;
            font-family: monospace;
            font-size: 14px;
            padding: 8px;
        }

        pre {
            background: #111;
            color: #0f0;
            overflow: auto;
        }

        button {
            padding: 6px 12px;
            margin-left: 8px;
            cursor: pointer;
        }

        .toolbar {
            display: flex;
            align-items: center;
        }
    </style>
</head>

<body>
<header>
    <div>УВМ — вариант 14 (стековая архитектура)</div>
    <div class="toolbar">
        <button id="run-btn">Ассемблировать и выполнить</button>
    </div>
</header>

<div class="container">
    <div class="panel">
        <label for="editor">Исходный код (ASM, формат: команда аргумент):</label>
        <textarea id="editor" spellcheck="false">
# Примеры из спецификации (вариант 14):
# Формат: команда пробел аргумент

load_const 831      # A=14, B=831 → 0xFE 0x33 0x00
read_value 97       # A=11, B=97 → 0x1B 0x06 0x00
write_value 291     # A=7, B=291 → 0x37 0x12 0x00
sgn 158             # A=4, B=158 → 0xE4 0x09 0x00

# Пример тестовой операции sgn():
# load_const 10
# ... остальная программа ...
        </textarea>
    </div>

    <div class="panel">
        <label for="output">Вывод (байт-код + лог + память в CSV):</label>
        <pre id="output">Нажмите "Ассемблировать и выполнить"</pre>
    </div>
</div>

<script>
    // =========================
    // Ассемблер (3 байта, стековая архитектура)
    // =========================

    const OP_LOAD_CONST = 14; // Загрузка константы на стек
    const OP_READ       = 11; // Чтение значения из памяти на стек
    const OP_WRITE      = 7;  // Запись значения с вершины стека в память
    const OP_SGN        = 4;  // Вычисление знака числа из памяти

    const OPCODE_NAMES = {
        [OP_LOAD_CONST]: "load_const",
        [OP_READ]:       "read_value",
        [OP_WRITE]:      "write_value",
        [OP_SGN]:        "sgn",
    };

    function packInstruction(a, b) {
        // A: 4 бита, B: 15 бит
        if (a < 0 || a >= (1 << 4)) {
            throw new Error("Поле A должно быть 0..15, получено " + a);
        }
        if (b < 0 || b >= (1 << 15)) {
            throw new Error("Поле B должно помещаться в 15 бит, получено " + b);
        }

        let value = a + (b << 4);

        const bytes = [];
        for (let i = 0; i < 3; i++) {
            bytes.push(value & 0xFF);
            value = value >> 8;
        }
        return bytes;
    }

    function asm_load_const(constVal) {
        return packInstruction(OP_LOAD_CONST, constVal);
    }

    function asm_read_value(address) {
        return packInstruction(OP_READ, address);
    }

    function asm_write_value(address) {
        return packInstruction(OP_WRITE, address);
    }

    function asm_sgn(address) {
        return packInstruction(OP_SGN, address);
    }

    function asm_from_IR(IR) {
        let bytecode = [];
        for (const item of IR) {
            const op = item[0];
            const arg = item[1];
            if (op === "load_const") {
                bytecode = bytecode.concat(asm_load_const(arg));
            } else if (op === "read_value") {
                bytecode = bytecode.concat(asm_read_value(arg));
            } else if (op === "write_value") {
                bytecode = bytecode.concat(asm_write_value(arg));
            } else if (op === "sgn") {
                bytecode = bytecode.concat(asm_sgn(arg));
            } else {
                throw new Error("Неизвестная команда ассемблера: " + op);
            }
        }
        return bytecode;
    }

    function full_asm(text) {
        const lines = text.split(/\r?\n/);
        const IR = [];

        for (let lineNum = 0; lineNum < lines.length; lineNum++) {
            let rawLine = lines[lineNum];
            let line = rawLine.trim();
            if (!line) continue;
            
            // Удаляем комментарии
            const hashIndex = line.indexOf("#");
            if (hashIndex !== -1) {
                line = line.slice(0, hashIndex).trim();
            }
            if (!line) continue;

            const parts = line.split(/\s+/);
            if (parts.length !== 2) {
                throw new Error(`Строка ${lineNum + 1}: ожидается 'команда аргумент', получено: '${rawLine.trim()}'`);
            }
            
            const cmd = parts[0].trim();
            const argStr = parts[1].trim();
            const arg = parseInt(argStr, 10);
            if (Number.isNaN(arg)) {
                throw new Error(`Строка ${lineNum + 1}: аргумент должен быть числом: '${argStr}'`);
            }

            IR.push([cmd, arg]);
        }

        const bytecode = asm_from_IR(IR);
        return { bytecode, IR };
    }

    // =========================
    // Модель памяти + интерпретатор (стековая)
    // =========================

    class UVMMemory {
        constructor(size = 2048) {
            this.data = new Array(size).fill(0);
            this.stack = [];
            this.ip = 0;
        }

        push(value) {
            this.stack.push(value);
        }

        pop() {
            if (this.stack.length === 0) {
                throw new Error("Стек пуст при выполнении POP");
            }
            return this.stack.pop();
        }

        readData(addr) {
            if (addr < 0 || addr >= this.data.length) {
                throw new Error("Недопустимый адрес чтения: " + addr);
            }
            return this.data[addr];
        }

        writeData(addr, value) {
            if (addr < 0 || addr >= this.data.length) {
                throw new Error("Недопустимый адрес записи: " + addr);
            }
            this.data[addr] = value;
        }
    }

    function decodeInstruction(bytes) {
        if (bytes.length !== 3) {
            throw new Error("Ожидалось 3 байта, получено " + bytes.length);
        }
        let value = 0;
        for (let i = 0; i < 3; i++) {
            value += bytes[i] << (8 * i);
        }
        const a = value & 0xF;
        const b = value >> 4;
        const cmdName = OPCODE_NAMES[a];
        if (!cmdName) {
            throw new Error("Неизвестный opcode (A): " + a);
        }
        return { cmd: cmdName, operand: b };
    }

    function runProgram(bytecode, memory) {
        const instrCount = Math.floor(bytecode.length / 3);
        const log = [];
        log.push(`[INFO] Запуск программы. Всего инструкций: ${instrCount}`);
        log.push(`[INFO] Начальное состояние стека: [${memory.stack}]`);

        while (memory.ip < instrCount) {
            const ip = memory.ip;
            const base = ip * 3;
            const instrBytes = bytecode.slice(base, base + 3);

            let decoded;
            try {
                decoded = decodeInstruction(instrBytes);
            } catch (e) {
                log.push(`[RUNTIME ERROR] На IP=${ip}: ${e.message}`);
                break;
            }

            const cmd = decoded.cmd;
            const B = decoded.operand;

            log.push(
                `[${String(ip).padStart(3, "0")}] ${cmd.padEnd(12, " ")} | B=${B} | Стек: [${memory.stack}]`
            );

            memory.ip = ip + 1;

            try {
                if (cmd === "load_const") {
                    memory.push(B);
                } else if (cmd === "read_value") {
                    const value = memory.readData(B);
                    memory.push(value);
                } else if (cmd === "write_value") {
                    const value = memory.pop();
                    memory.writeData(B, value);
                } else if (cmd === "sgn") {
                    const value = memory.readData(B);
                    let result;
                    if (value > 0) result = 1;
                    else if (value < 0) result = -1;
                    else result = 0;
                    memory.push(result);
                } else {
                    log.push(`[RUNTIME ERROR] Неизвестная команда: ${cmd}`);
                    break;
                }
            } catch (e) {
                log.push(`[RUNTIME ERROR] ${e.message}`);
                break;
            }
        }

        log.push("");
        log.push(`--- Выполнение завершено на IP=${memory.ip} ---`);
        log.push(`Финальный стек: [${memory.stack}]`);
        log.push(`Память (первые 16 ячеек): [${memory.data.slice(0, 16).join(", ")}]`);

        return log.join("\n");
    }

    // =========================
    // Генерация CSV дампа (в текстовом виде)
    // =========================

    function generateCSVDump(memory, startAddr, endAddr) {
        let csv = "Тип,Адрес/Индекс,Значение\n";
        
        // Стек
        csv += `СТЕК,РАЗМЕР,${memory.stack.length}\n`;
        for (let i = memory.stack.length - 1, j = 0; i >= 0; i--, j++) {
            csv += `СТЕК,stack[${j}],${memory.stack[i]}\n`;
        }
        
        // Регистры
        csv += `РЕГИСТРЫ,IP,${memory.ip}\n`;
        
        // Память
        csv += `ПАМЯТЬ,ДИАПАЗОН,${startAddr}-${endAddr}\n`;
        const end = Math.min(endAddr + 1, memory.data.length);
        for (let addr = startAddr; addr < end; addr++) {
            csv += `ПАМЯТЬ,${addr},${memory.data[addr]}\n`;
        }
        
        return csv;
    }

    // =========================
    // Обработчик кнопки
    // =========================

    function runUVM() {
        const editor = document.getElementById("editor");
        const output = document.getElementById("output");
        const src = editor.value;

        if (!src.trim()) {
            output.textContent = "[WARN] Исходный текст пуст.";
            return;
        }

        try {
            const { bytecode, IR } = full_asm(src);

            // Байткод в hex
            const hexBytes = bytecode
                .map(b => "0x" + b.toString(16).toUpperCase().padStart(2, "0"))
                .join(" ");

            const mem = new UVMMemory();
            const log = runProgram(bytecode, mem);

            // Генерация CSV дампа
            const csvDump = generateCSVDump(mem, 0, 31);

            // IR представление
            let irText = "";
            for (let i = 0; i < IR.length; i++) {
                irText += `[${i.toString().padStart(2, '0')}] ${IR[i][0].padEnd(12)} ${IR[i][1]}\n`;
            }

            const result =
                "--- Сгенерированный байт-код ---\n" +
                hexBytes +
                "\n\n--- Промежуточное представление (IR) ---\n" +
                irText +
                "\n--- Лог выполнения ---\n" +
                log +
                "\n--- Дамп памяти (CSV, адреса 0..31) ---\n" +
                csvDump;

            output.textContent = result;
        } catch (e) {
            output.textContent = "[ERROR] " + e.message;
        }
    }

    document.getElementById("run-btn").addEventListener("click", runUVM);
</script>

</body>
</html>